from __future__ import annotations

import asyncio
import os
import time
from contextlib import asynccontextmanager

from fastapi import FastAPI
from fastapi.responses import PlainTextResponse

from docker_healthcheck_exporter.collector import ContainerStatus, DockerCollector
from docker_healthcheck_exporter.config import load_settings
from docker_healthcheck_exporter.logger import get_logger
from docker_healthcheck_exporter.metrics import render_metrics

logger = get_logger(__name__)


class ExporterState:
    def __init__(self) -> None:
        """
        Initializes the exporter state.

        This includes loading the configuration, creating a collector
        instance, and initializing the state variables.

        :return: None
        """
        self.settings = load_settings()
        self.collector = DockerCollector(
            ignore_list=self.settings.services_ignore_list,
            include_label=self.settings.include_label,
            max_concurrency=self.settings.max_concurrency,
        )

        self.snapshot: dict[str, ContainerStatus] = {}
        self.last_ok_ts: float = 0.0

        self.exporter_up: int = 0
        self.refresh_errors_total: int = 0
        self.refresh_duration_seconds: float = 0.0

        self._stop = asyncio.Event()
        self._task: asyncio.Task | None = None

    async def start(self) -> None:
        """
        Starts the exporter.

        This method starts the Docker collector and schedules the refresh
        loop.

        :return: None
        """
        logger.info("Starting exporter")
        await self.collector.start()
        self._task = asyncio.create_task(self._loop(), name="docker-refresh-loop")

    async def stop(self) -> None:
        """
        Stops the exporter.

        This method stops the Docker collector and cancels the refresh loop.

        :return: None
        """
        logger.info("Stopping exporter")
        self._stop.set()
        if self._task:
            self._task.cancel()
            try:
                await self._task
            except asyncio.CancelledError:
                pass
        await self.collector.stop()

    async def _loop(self) -> None:
        """
        Internal loop that runs the exporter.

        This method runs an infinite loop that waits for the configured
        refresh interval, collects the container health status, and updates
        the exporter's metrics.

        If the configured metrics file is set, the loop will write the metrics
        to the file after each successful collection.

        :return: None
        """
        interval = max(1.0, self.settings.refresh_interval_seconds)
        while not self._stop.is_set():
            t0 = time.perf_counter()
            try:
                snap = await self.collector.collect()
                self.snapshot = snap
                self.last_ok_ts = time.time()
                self.exporter_up = 1
            except Exception:
                self.refresh_errors_total += 1
                self.exporter_up = 0
                logger.exception("Failed to collect Docker health status")
            finally:
                self.refresh_duration_seconds = max(0.0, time.perf_counter() - t0)

            if self.settings.metrics_file:
                try:
                    _write_metrics_file(self.settings.metrics_file, self.metrics_text())
                except Exception:
                    logger.exception(f"Failed to write metrics file: {self.settings.metrics_file}")

            try:
                await asyncio.wait_for(self._stop.wait(), timeout=interval)
            except asyncio.TimeoutError:
                pass

    def metrics_text(self) -> str:
        """
        Returns a string containing the metrics for the exporter.

        The metrics are generated by calling render_metrics with the current state
        of the exporter. The snapshot_age_seconds metric is calculated by
        subtracting the last_ok_ts from the current time.

        :return: A string containing the metrics for the exporter.
        :rtype: str
        """
        now = time.time()
        age = (now - self.last_ok_ts) if self.last_ok_ts else float("inf")
        return render_metrics(
            instance_name=self.settings.instance_name,
            snapshot=self.snapshot,
            exporter_up=self.exporter_up,
            refresh_errors_total=self.refresh_errors_total,
            refresh_duration_seconds=self.refresh_duration_seconds,
            snapshot_age_seconds=age if age != float("inf") else 0.0,
        )


state = ExporterState()


@asynccontextmanager
async def lifespan(app: FastAPI):
    """
    Context manager that starts the exporter state on entering and stops it on exiting.

    This context manager is used to start the exporter state before the first request
    and stop it after the last request. It ensures that the exporter state is properly
    initialized and cleaned up.

    :param app: The FastAPI application instance.
    :type app: FastAPI
    """
    await state.start()
    yield
    await state.stop()


app = FastAPI(lifespan=lifespan)


@app.get("/metrics", response_class=PlainTextResponse)
async def metrics():
    """
    Returns a string containing the metrics for the exporter.

    The metrics are generated by calling render_metrics with the current state
    of the exporter. The snapshot_age_seconds metric is calculated by
    subtracting the last_ok_ts from the current time.

    :return: A string containing the metrics for the exporter.
    :rtype: str
    """
    return state.metrics_text()


@app.get("/health", response_class=PlainTextResponse)
async def health():
    """
    Returns a simple health check response.

    :return: A JSON encoded string indicating the health of the exporter.
    :rtype: str
    """
    return "{'status': 'ok'}"


def _write_metrics_file(path: str, text: str) -> None:
    """
    Atomically write metrics to a file.

    :param path: The path to the file to write.
    :param text: The metrics text to write.
    :return: None
    """
    dir_name = os.path.dirname(path)
    if dir_name:
        os.makedirs(dir_name, exist_ok=True)
    tmp_path = f"{path}.tmp"
    with open(tmp_path, "w", encoding="utf-8") as f:
        f.write(text)
    os.replace(tmp_path, path)
